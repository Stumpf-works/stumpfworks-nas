// Revision: 2025-11-16 | Author: StumpfWorks AI | Version: 1.1.0
package system

import (
	"context"
	"fmt"
	"runtime"
	"sync"
	"time"

	"github.com/shirou/gopsutil/v3/cpu"
	"github.com/shirou/gopsutil/v3/disk"
	"github.com/shirou/gopsutil/v3/host"
	"github.com/shirou/gopsutil/v3/load"
	"github.com/shirou/gopsutil/v3/mem"
	"github.com/shirou/gopsutil/v3/net"
	"github.com/Stumpf-works/stumpfworks-nas/pkg/logger"
	"go.uber.org/zap"
)

// MetricsCollector collects system metrics for monitoring and Prometheus export
type MetricsCollector struct {
	interval time.Duration
	mu       sync.RWMutex
	current  *SystemMetrics
	history  []*SystemMetrics
	maxHistory int
}

// SystemMetrics contains all system metrics
type SystemMetrics struct {
	Timestamp time.Time `json:"timestamp"`

	// CPU Metrics
	CPUUsagePercent    float64   `json:"cpu_usage_percent"`
	CPUCores           int       `json:"cpu_cores"`
	CPUPerCoreUsage    []float64 `json:"cpu_per_core_usage"`
	LoadAverage1       float64   `json:"load_average_1"`
	LoadAverage5       float64   `json:"load_average_5"`
	LoadAverage15      float64   `json:"load_average_15"`

	// Memory Metrics
	MemoryTotal        uint64  `json:"memory_total_bytes"`
	MemoryUsed         uint64  `json:"memory_used_bytes"`
	MemoryFree         uint64  `json:"memory_free_bytes"`
	MemoryUsagePercent float64 `json:"memory_usage_percent"`
	SwapTotal          uint64  `json:"swap_total_bytes"`
	SwapUsed           uint64  `json:"swap_used_bytes"`
	SwapFree           uint64  `json:"swap_free_bytes"`
	SwapUsagePercent   float64 `json:"swap_usage_percent"`

	// Disk Metrics (root partition)
	DiskTotal          uint64  `json:"disk_total_bytes"`
	DiskUsed           uint64  `json:"disk_used_bytes"`
	DiskFree           uint64  `json:"disk_free_bytes"`
	DiskUsagePercent   float64 `json:"disk_usage_percent"`

	// Network Metrics
	NetworkBytesSent   uint64 `json:"network_bytes_sent_total"`
	NetworkBytesRecv   uint64 `json:"network_bytes_recv_total"`
	NetworkPacketsSent uint64 `json:"network_packets_sent_total"`
	NetworkPacketsRecv uint64 `json:"network_packets_recv_total"`

	// System Info
	Uptime             uint64 `json:"uptime_seconds"`
	BootTime           uint64 `json:"boot_time"`
	Processes          uint64 `json:"processes_total"`

	// Go Runtime Metrics
	GoVersion          string `json:"go_version"`
	GoRoutines         int    `json:"goroutines"`
	GoMemAlloc         uint64 `json:"go_mem_alloc_bytes"`
	GoMemSys           uint64 `json:"go_mem_sys_bytes"`
	GoGCPauseNs        uint64 `json:"go_gc_pause_ns"`

	// NAS-Specific Metrics
	ZFSPools           []ZFSPoolMetric    `json:"zfs_pools,omitempty"`
	DiskSMART          []DiskSMARTMetric  `json:"disk_smart,omitempty"`
	Services           []ServiceMetric     `json:"services,omitempty"`
	ShareConnections   ShareConnectionMetrics `json:"share_connections,omitempty"`
}

// ZFSPoolMetric represents metrics for a single ZFS pool
type ZFSPoolMetric struct {
	Name        string  `json:"name"`
	Health      string  `json:"health"`
	HealthValue float64 `json:"health_value"` // 1=ONLINE, 0.5=DEGRADED, 0=OFFLINE
	TotalBytes  uint64  `json:"total_bytes"`
	UsedBytes   uint64  `json:"used_bytes"`
	FreeBytes   uint64  `json:"free_bytes"`
}

// DiskSMARTMetric represents SMART metrics for a single disk
type DiskSMARTMetric struct {
	Device      string  `json:"device"`
	Healthy     float64 `json:"healthy"` // 1=healthy, 0=unhealthy
	Temperature float64 `json:"temperature_celsius"`
}

// ServiceMetric represents the status of a system service
type ServiceMetric struct {
	Name   string  `json:"name"`
	Status float64 `json:"status"` // 1=running, 0=stopped
}

// ShareConnectionMetrics represents active share connections
type ShareConnectionMetrics struct {
	SambaConnections int `json:"samba_connections"`
	NFSConnections   int `json:"nfs_connections"`
}

// NewMetricsCollector creates a new metrics collector
func NewMetricsCollector(interval time.Duration) (*MetricsCollector, error) {
	if interval <= 0 {
		interval = 10 * time.Second
	}

	mc := &MetricsCollector{
		interval:   interval,
		history:    make([]*SystemMetrics, 0, 100),
		maxHistory: 100, // Keep last 100 readings
	}

	// Collect initial metrics
	if err := mc.collect(); err != nil {
		return nil, fmt.Errorf("failed to collect initial metrics: %w", err)
	}

	return mc, nil
}

// Start starts the metrics collection in background
func (mc *MetricsCollector) Start(ctx context.Context) error {
	go mc.run(ctx)
	logger.Info("Metrics collector started", zap.Duration("interval", mc.interval))
	return nil
}

// Stop stops the metrics collection
func (mc *MetricsCollector) Stop() error {
	logger.Info("Metrics collector stopped")
	return nil
}

// run is the main loop for metrics collection
func (mc *MetricsCollector) run(ctx context.Context) {
	ticker := time.NewTicker(mc.interval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			if err := mc.collect(); err != nil {
				logger.Error("Failed to collect metrics", zap.Error(err))
			}
		}
	}
}

// collect collects all system metrics
func (mc *MetricsCollector) collect() error {
	metrics := &SystemMetrics{
		Timestamp: time.Now(),
	}

	// Collect CPU metrics
	if err := mc.collectCPU(metrics); err != nil {
		logger.Warn("Failed to collect CPU metrics", zap.Error(err))
	}

	// Collect memory metrics
	if err := mc.collectMemory(metrics); err != nil {
		logger.Warn("Failed to collect memory metrics", zap.Error(err))
	}

	// Collect disk metrics
	if err := mc.collectDisk(metrics); err != nil {
		logger.Warn("Failed to collect disk metrics", zap.Error(err))
	}

	// Collect network metrics
	if err := mc.collectNetwork(metrics); err != nil {
		logger.Warn("Failed to collect network metrics", zap.Error(err))
	}

	// Collect system info
	if err := mc.collectSystemInfo(metrics); err != nil {
		logger.Warn("Failed to collect system info", zap.Error(err))
	}

	// Collect Go runtime metrics
	mc.collectGoRuntime(metrics)

	// Collect NAS-specific metrics
	mc.collectZFSMetrics(metrics)
	mc.collectSMARTMetrics(metrics)
	mc.collectServiceMetrics(metrics)
	mc.collectShareConnections(metrics)

	// Store metrics
	mc.mu.Lock()
	mc.current = metrics
	mc.history = append(mc.history, metrics)
	if len(mc.history) > mc.maxHistory {
		mc.history = mc.history[1:]
	}
	mc.mu.Unlock()

	return nil
}

// collectCPU collects CPU metrics
func (mc *MetricsCollector) collectCPU(metrics *SystemMetrics) error {
	// CPU usage (average across all cores)
	percentages, err := cpu.Percent(0, false)
	if err != nil {
		return err
	}
	if len(percentages) > 0 {
		metrics.CPUUsagePercent = percentages[0]
	}

	// Per-core usage
	perCorePercentages, err := cpu.Percent(0, true)
	if err == nil {
		metrics.CPUPerCoreUsage = perCorePercentages
		metrics.CPUCores = len(perCorePercentages)
	}

	// Load average
	loadAvg, err := load.Avg()
	if err == nil {
		metrics.LoadAverage1 = loadAvg.Load1
		metrics.LoadAverage5 = loadAvg.Load5
		metrics.LoadAverage15 = loadAvg.Load15
	}

	return nil
}

// collectMemory collects memory metrics
func (mc *MetricsCollector) collectMemory(metrics *SystemMetrics) error {
	// Virtual memory
	vmem, err := mem.VirtualMemory()
	if err != nil {
		return err
	}

	metrics.MemoryTotal = vmem.Total
	metrics.MemoryUsed = vmem.Used
	metrics.MemoryFree = vmem.Free
	metrics.MemoryUsagePercent = vmem.UsedPercent

	// Swap memory
	swap, err := mem.SwapMemory()
	if err == nil {
		metrics.SwapTotal = swap.Total
		metrics.SwapUsed = swap.Used
		metrics.SwapFree = swap.Free
		metrics.SwapUsagePercent = swap.UsedPercent
	}

	return nil
}

// collectDisk collects disk metrics
func (mc *MetricsCollector) collectDisk(metrics *SystemMetrics) error {
	// Root partition
	usage, err := disk.Usage("/")
	if err != nil {
		return err
	}

	metrics.DiskTotal = usage.Total
	metrics.DiskUsed = usage.Used
	metrics.DiskFree = usage.Free
	metrics.DiskUsagePercent = usage.UsedPercent

	return nil
}

// collectNetwork collects network metrics
func (mc *MetricsCollector) collectNetwork(metrics *SystemMetrics) error {
	counters, err := net.IOCounters(false)
	if err != nil {
		return err
	}

	if len(counters) > 0 {
		metrics.NetworkBytesSent = counters[0].BytesSent
		metrics.NetworkBytesRecv = counters[0].BytesRecv
		metrics.NetworkPacketsSent = counters[0].PacketsSent
		metrics.NetworkPacketsRecv = counters[0].PacketsRecv
	}

	return nil
}

// collectSystemInfo collects system info
func (mc *MetricsCollector) collectSystemInfo(metrics *SystemMetrics) error {
	info, err := host.Info()
	if err != nil {
		return err
	}

	metrics.Uptime = info.Uptime
	metrics.BootTime = info.BootTime
	metrics.Processes = info.Procs

	return nil
}

// collectGoRuntime collects Go runtime metrics
func (mc *MetricsCollector) collectGoRuntime(metrics *SystemMetrics) {
	metrics.GoVersion = runtime.Version()
	metrics.GoRoutines = runtime.NumGoroutine()

	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	metrics.GoMemAlloc = m.Alloc
	metrics.GoMemSys = m.Sys
	metrics.GoGCPauseNs = m.PauseNs[(m.NumGC+255)%256]
}

// collectZFSMetrics collects ZFS pool metrics
func (mc *MetricsCollector) collectZFSMetrics(metrics *SystemMetrics) {
	// Get ZFS manager from global system instance
	sys := Get()
	if sys == nil || sys.Storage == nil {
		return
	}

	pools, err := sys.Storage.ZFS.ListPools()
	if err != nil {
		// ZFS might not be available on all systems
		return
	}

	metrics.ZFSPools = make([]ZFSPoolMetric, 0, len(pools))
	for _, pool := range pools {
		healthValue := 0.0
		switch pool.Health {
		case "ONLINE":
			healthValue = 1.0
		case "DEGRADED":
			healthValue = 0.5
		case "OFFLINE", "FAULTED", "UNAVAIL":
			healthValue = 0.0
		default:
			healthValue = 0.5
		}

		metrics.ZFSPools = append(metrics.ZFSPools, ZFSPoolMetric{
			Name:        pool.Name,
			Health:      pool.Health,
			HealthValue: healthValue,
			TotalBytes:  pool.Size,
			UsedBytes:   pool.Allocated,
			FreeBytes:   pool.Free,
		})
	}
}

// collectSMARTMetrics collects SMART disk health metrics
func (mc *MetricsCollector) collectSMARTMetrics(metrics *SystemMetrics) {
	sys := Get()
	if sys == nil || sys.Storage == nil {
		return
	}

	// Get list of physical disks
	disks, err := sys.Storage.ListDisks()
	if err != nil {
		return
	}

	metrics.DiskSMART = make([]DiskSMARTMetric, 0)
	for _, disk := range disks {
		// Get SMART info for each disk
		smart, err := sys.Storage.GetDiskSMART(disk)
		if err != nil {
			continue
		}

		healthy := 0.0
		if smart.Healthy {
			healthy = 1.0
		}

		metrics.DiskSMART = append(metrics.DiskSMART, DiskSMARTMetric{
			Device:      disk,
			Healthy:     healthy,
			Temperature: float64(smart.Temperature),
		})
	}
}

// collectServiceMetrics collects system service status metrics
func (mc *MetricsCollector) collectServiceMetrics(metrics *SystemMetrics) {
	sys := Get()
	if sys == nil {
		return
	}

	// List of critical NAS services to monitor
	services := []string{
		"smbd",      // Samba server
		"nmbd",      // Samba NetBIOS
		"nfs-server", // NFS server
		"docker",    // Docker daemon
		"sshd",      // SSH daemon
	}

	metrics.Services = make([]ServiceMetric, 0, len(services))
	for _, svc := range services {
		status := 0.0
		// Check if service is running
		if isServiceRunning(svc) {
			status = 1.0
		}

		metrics.Services = append(metrics.Services, ServiceMetric{
			Name:   svc,
			Status: status,
		})
	}
}

// collectShareConnections collects active share connection counts
func (mc *MetricsCollector) collectShareConnections(metrics *SystemMetrics) {
	sys := Get()
	if sys == nil || sys.Sharing == nil {
		return
	}

	// Count Samba connections
	sambaConns := 0
	if status, err := sys.Sharing.Samba.GetStatus(); err == nil && status.Active {
		// Parse smbstatus output to count connections
		// For now, default to 0 as we need smbstatus command parsing
		sambaConns = 0
	}

	// Count NFS connections
	nfsConns := 0
	// NFS connections can be counted from /proc/net/rpc/nfsd
	// For now, default to 0
	nfsConns = 0

	metrics.ShareConnections = ShareConnectionMetrics{
		SambaConnections: sambaConns,
		NFSConnections:   nfsConns,
	}
}

// isServiceRunning checks if a systemd service is running
func isServiceRunning(serviceName string) bool {
	sys := Get()
	if sys == nil {
		return false
	}

	output, err := sys.RunCommand("systemctl", "is-active", serviceName)
	if err != nil {
		return false
	}

	return output == "active"
}

// GetCurrent returns the current metrics
func (mc *MetricsCollector) GetCurrent() *SystemMetrics {
	mc.mu.RLock()
	defer mc.mu.RUnlock()
	return mc.current
}

// GetHistory returns the metrics history
func (mc *MetricsCollector) GetHistory() []*SystemMetrics {
	mc.mu.RLock()
	defer mc.mu.RUnlock()

	// Return a copy to prevent concurrent access issues
	history := make([]*SystemMetrics, len(mc.history))
	copy(history, mc.history)
	return history
}

// GetHistorySince returns metrics since a specific time
func (mc *MetricsCollector) GetHistorySince(since time.Time) []*SystemMetrics {
	mc.mu.RLock()
	defer mc.mu.RUnlock()

	var result []*SystemMetrics
	for _, m := range mc.history {
		if m.Timestamp.After(since) {
			result = append(result, m)
		}
	}
	return result
}

// ToPrometheusFormat converts metrics to Prometheus text format
func (m *SystemMetrics) ToPrometheusFormat() string {
	var output string

	// Helper function to add metric
	addMetric := func(name, metricType, help string, value interface{}) {
		output += fmt.Sprintf("# HELP %s %s\n", name, help)
		output += fmt.Sprintf("# TYPE %s %s\n", name, metricType)
		output += fmt.Sprintf("%s %v\n\n", name, value)
	}

	// CPU Metrics
	addMetric("stumpfworks_cpu_usage_percent", "gauge", "CPU usage percentage", m.CPUUsagePercent)
	addMetric("stumpfworks_cpu_cores", "gauge", "Number of CPU cores", m.CPUCores)
	addMetric("stumpfworks_load_average_1", "gauge", "Load average 1 minute", m.LoadAverage1)
	addMetric("stumpfworks_load_average_5", "gauge", "Load average 5 minutes", m.LoadAverage5)
	addMetric("stumpfworks_load_average_15", "gauge", "Load average 15 minutes", m.LoadAverage15)

	// Memory Metrics
	addMetric("stumpfworks_memory_total_bytes", "gauge", "Total memory in bytes", m.MemoryTotal)
	addMetric("stumpfworks_memory_used_bytes", "gauge", "Used memory in bytes", m.MemoryUsed)
	addMetric("stumpfworks_memory_free_bytes", "gauge", "Free memory in bytes", m.MemoryFree)
	addMetric("stumpfworks_memory_usage_percent", "gauge", "Memory usage percentage", m.MemoryUsagePercent)
	addMetric("stumpfworks_swap_total_bytes", "gauge", "Total swap in bytes", m.SwapTotal)
	addMetric("stumpfworks_swap_used_bytes", "gauge", "Used swap in bytes", m.SwapUsed)
	addMetric("stumpfworks_swap_usage_percent", "gauge", "Swap usage percentage", m.SwapUsagePercent)

	// Disk Metrics
	addMetric("stumpfworks_disk_total_bytes", "gauge", "Total disk space in bytes", m.DiskTotal)
	addMetric("stumpfworks_disk_used_bytes", "gauge", "Used disk space in bytes", m.DiskUsed)
	addMetric("stumpfworks_disk_free_bytes", "gauge", "Free disk space in bytes", m.DiskFree)
	addMetric("stumpfworks_disk_usage_percent", "gauge", "Disk usage percentage", m.DiskUsagePercent)

	// Network Metrics
	addMetric("stumpfworks_network_bytes_sent_total", "counter", "Total bytes sent", m.NetworkBytesSent)
	addMetric("stumpfworks_network_bytes_recv_total", "counter", "Total bytes received", m.NetworkBytesRecv)
	addMetric("stumpfworks_network_packets_sent_total", "counter", "Total packets sent", m.NetworkPacketsSent)
	addMetric("stumpfworks_network_packets_recv_total", "counter", "Total packets received", m.NetworkPacketsRecv)

	// System Info
	addMetric("stumpfworks_uptime_seconds", "counter", "System uptime in seconds", m.Uptime)
	addMetric("stumpfworks_processes_total", "gauge", "Total number of processes", m.Processes)

	// Go Runtime Metrics
	addMetric("stumpfworks_go_goroutines", "gauge", "Number of goroutines", m.GoRoutines)
	addMetric("stumpfworks_go_mem_alloc_bytes", "gauge", "Go memory allocated bytes", m.GoMemAlloc)
	addMetric("stumpfworks_go_mem_sys_bytes", "gauge", "Go memory system bytes", m.GoMemSys)
	addMetric("stumpfworks_go_gc_pause_ns", "gauge", "Go GC pause nanoseconds", m.GoGCPauseNs)

	// ZFS Pool Metrics
	if len(m.ZFSPools) > 0 {
		output += "# HELP stumpfworks_zfs_pool_health ZFS pool health status (1=ONLINE, 0.5=DEGRADED, 0=OFFLINE)\n"
		output += "# TYPE stumpfworks_zfs_pool_health gauge\n"
		for _, pool := range m.ZFSPools {
			output += fmt.Sprintf("stumpfworks_zfs_pool_health{pool=\"%s\",health=\"%s\"} %v\n", pool.Name, pool.Health, pool.HealthValue)
		}
		output += "\n"

		output += "# HELP stumpfworks_zfs_pool_total_bytes ZFS pool total size in bytes\n"
		output += "# TYPE stumpfworks_zfs_pool_total_bytes gauge\n"
		for _, pool := range m.ZFSPools {
			output += fmt.Sprintf("stumpfworks_zfs_pool_total_bytes{pool=\"%s\"} %v\n", pool.Name, pool.TotalBytes)
		}
		output += "\n"

		output += "# HELP stumpfworks_zfs_pool_used_bytes ZFS pool used space in bytes\n"
		output += "# TYPE stumpfworks_zfs_pool_used_bytes gauge\n"
		for _, pool := range m.ZFSPools {
			output += fmt.Sprintf("stumpfworks_zfs_pool_used_bytes{pool=\"%s\"} %v\n", pool.Name, pool.UsedBytes)
		}
		output += "\n"

		output += "# HELP stumpfworks_zfs_pool_free_bytes ZFS pool free space in bytes\n"
		output += "# TYPE stumpfworks_zfs_pool_free_bytes gauge\n"
		for _, pool := range m.ZFSPools {
			output += fmt.Sprintf("stumpfworks_zfs_pool_free_bytes{pool=\"%s\"} %v\n", pool.Name, pool.FreeBytes)
		}
		output += "\n"
	}

	// SMART Disk Metrics
	if len(m.DiskSMART) > 0 {
		output += "# HELP stumpfworks_disk_smart_healthy Disk SMART health status (1=healthy, 0=unhealthy)\n"
		output += "# TYPE stumpfworks_disk_smart_healthy gauge\n"
		for _, disk := range m.DiskSMART {
			output += fmt.Sprintf("stumpfworks_disk_smart_healthy{device=\"%s\"} %v\n", disk.Device, disk.Healthy)
		}
		output += "\n"

		output += "# HELP stumpfworks_disk_temperature_celsius Disk temperature in Celsius\n"
		output += "# TYPE stumpfworks_disk_temperature_celsius gauge\n"
		for _, disk := range m.DiskSMART {
			output += fmt.Sprintf("stumpfworks_disk_temperature_celsius{device=\"%s\"} %v\n", disk.Device, disk.Temperature)
		}
		output += "\n"
	}

	// Service Status Metrics
	if len(m.Services) > 0 {
		output += "# HELP stumpfworks_service_status Service status (1=running, 0=stopped)\n"
		output += "# TYPE stumpfworks_service_status gauge\n"
		for _, svc := range m.Services {
			output += fmt.Sprintf("stumpfworks_service_status{service=\"%s\"} %v\n", svc.Name, svc.Status)
		}
		output += "\n"
	}

	// Share Connection Metrics
	addMetric("stumpfworks_samba_connections_total", "gauge", "Number of active Samba connections", m.ShareConnections.SambaConnections)
	addMetric("stumpfworks_nfs_connections_total", "gauge", "Number of active NFS connections", m.ShareConnections.NFSConnections)

	return output
}
